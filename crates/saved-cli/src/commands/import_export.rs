//! Import/export commands

use crate::utils::formatting::print_warning;
use crate::utils::validation::validate_file_path;
use anyhow::Result;
use colored::*;
use saved_core::{create_or_open_account, Config};
use std::path::PathBuf;

/// Export messages to JSON
pub async fn export_command(account_path: &PathBuf, output: &PathBuf, verbose: bool) -> Result<()> {
    if verbose {
        println!("Exporting messages to JSON...");
        println!("Output file: {}", output.display());
    }

    // Create configuration
    let config = Config {
        storage_path: account_path.clone(),
        network_port: 8080,
        enable_mdns: true,
        allow_public_relays: false,
        bootstrap_multiaddrs: Vec::new(),
        use_kademlia: false,
        chunk_size: 2 * 1024 * 1024, // 2 MiB
        max_parallel_chunks: 4,
        storage_backend: saved_core::storage::StorageBackend::Sqlite,
        account_passphrase: None,
    };

    // Open account
    let account = create_or_open_account(config).await?;

    // Fetch real messages from core
    let messages = account
        .list_messages()
        .await
        .map_err(|e| anyhow::anyhow!("Failed to list messages: {}", e))?;

    // Map messages to export-friendly JSON
    let messages_json: Vec<serde_json::Value> = messages
        .into_iter()
        .map(|m| {
            serde_json::json!({
                "id": hex::encode(m.id.as_bytes()),
                "content": m.content,
                "created_at": m.created_at.to_rfc3339(),
                "is_deleted": m.is_deleted,
                "is_purged": m.is_purged,
            })
        })
        .collect();

    // Create export data structure
    let export_data = serde_json::json!({
        "version": "1.0",
        "exported_at": chrono::Utc::now().to_rfc3339(),
        "account_path": account_path.to_string_lossy(),
        "device_info": account.device_info().await,
        "messages": messages_json,
        "note": "Export generated by saved-cli-rs"
    });

    // Write to file
    let json_string = serde_json::to_string_pretty(&export_data)?;
    std::fs::write(output, json_string)?;

    println!("{}", "✓ Messages exported successfully!".green().bold());
    println!(
        "Output file: {}",
        output.display().to_string().bright_blue()
    );
    if verbose {
        println!(
            "Exported {} messages",
            export_data["messages"]
                .as_array()
                .map(|a| a.len())
                .unwrap_or(0)
        );
    }

    Ok(())
}

/// Import messages from JSON
pub async fn import_command(account_path: &PathBuf, input: &PathBuf, verbose: bool) -> Result<()> {
    if verbose {
        println!("Importing messages from JSON...");
        println!("Input file: {}", input.display());
    }

    // Validate input file
    validate_file_path(input)?;

    // Read and parse JSON file
    let json_string = std::fs::read_to_string(input)?;
    let import_data: serde_json::Value = serde_json::from_str(&json_string)?;

    if verbose {
        println!(
            "Import data: {}",
            serde_json::to_string_pretty(&import_data)?
        );
    }

    // Create configuration
    let config = Config {
        storage_path: account_path.clone(),
        network_port: 8080,
        enable_mdns: true,
        allow_public_relays: false,
        bootstrap_multiaddrs: Vec::new(),
        use_kademlia: false,
        chunk_size: 2 * 1024 * 1024, // 2 MiB
        max_parallel_chunks: 4,
        storage_backend: saved_core::storage::StorageBackend::Sqlite,
        account_passphrase: None,
    };

    // Open account
    let mut account = create_or_open_account(config).await?;

    // Check version compatibility
    if let Some(version) = import_data.get("version") {
        if version != "1.0" {
            print_warning("Import file version mismatch");
        }
    }

    // Import messages with comprehensive validation and error handling
    if let Some(messages) = import_data.get("messages") {
        if let Some(messages_array) = messages.as_array() {
            println!("Found {} messages to import", messages_array.len());

            let mut imported_count = 0;
            let mut skipped_count = 0;

            for (i, message) in messages_array.iter().enumerate() {
                if verbose {
                    println!("Processing message {}: {}", i + 1, message);
                }

                // Validate message structure (support both `body` and `content` keys)
                let body_field = message
                    .get("body")
                    .and_then(|v| v.as_str())
                    .or_else(|| message.get("content").and_then(|v| v.as_str()));
                if let Some(body) = body_field {
                    // Validate message content
                    if body.trim().is_empty() {
                        if verbose {
                            println!("  ⚠ Skipping empty message {}", i + 1);
                        }
                        skipped_count += 1;
                        continue;
                    }

                    // Check message length
                    if body.len() > 10000 {
                        if verbose {
                            println!(
                                "  ⚠ Skipping message {} (too long: {} chars)",
                                i + 1,
                                body.len()
                            );
                        }
                        skipped_count += 1;
                        continue;
                    }

                    // Import message using the core library
                    match account.create_message(body.to_string(), Vec::new()).await {
                        Ok(_) => {
                            imported_count += 1;
                            if verbose {
                                println!(
                                    "  ✓ Imported: {}",
                                    if body.len() > 50 {
                                        format!("{}...", &body[..50])
                                    } else {
                                        body.to_string()
                                    }
                                );
                            }
                        }
                        Err(e) => {
                            println!("  ✗ Failed to import message {}: {}", i + 1, e);
                            skipped_count += 1;
                        }
                    }
                } else {
                    if verbose {
                        println!("  ⚠ Skipping message {} (no body/content field)", i + 1);
                    }
                    skipped_count += 1;
                }
            }

            println!(
                "Import summary: {} imported, {} skipped",
                imported_count, skipped_count
            );
        }
    }

    println!("{}", "✓ Messages imported successfully!".green().bold());
    println!("Input file: {}", input.display().to_string().bright_blue());
    if verbose {
        println!("Import completed");
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_export_then_import_roundtrip() {
        let temp_dir = TempDir::new().unwrap();
        let account_path = temp_dir.path().join("acc");
        std::fs::create_dir_all(&account_path).unwrap();
        let export_path = temp_dir.path().join("export.json");

        // Prepare account with one message via core directly
        let config = Config {
            storage_path: account_path.clone(),
            network_port: 0,
            enable_mdns: false,
            allow_public_relays: false,
            bootstrap_multiaddrs: Vec::new(),
            use_kademlia: false,
            chunk_size: 2 * 1024 * 1024,
            max_parallel_chunks: 4,
            storage_backend: saved_core::storage::StorageBackend::Sqlite,
            account_passphrase: None,
        };
        let mut handle = create_or_open_account(config).await.unwrap();
        handle
            .create_message("hello from test".to_string(), Vec::new())
            .await
            .unwrap();

        // Export
        export_command(&account_path, &export_path, true)
            .await
            .unwrap();
        let json = std::fs::read_to_string(&export_path).unwrap();
        let v: serde_json::Value = serde_json::from_str(&json).unwrap();
        assert!(v["messages"].as_array().unwrap().len() >= 1);

        // Import into a new account path
        let import_account_path = temp_dir.path().join("acc2");
        std::fs::create_dir_all(&import_account_path).unwrap();
        import_command(&import_account_path, &export_path, true)
            .await
            .unwrap();

        // Verify imported message exists
        let config2 = Config {
            storage_path: import_account_path.clone(),
            ..Config::default()
        };
        let handle2 = create_or_open_account(config2).await.unwrap();
        let msgs = handle2.list_messages().await.unwrap();
        assert!(msgs.iter().any(|m| m.content == "hello from test"));
    }
}
